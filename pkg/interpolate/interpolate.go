// Copyright 2020 Mia srl
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package interpolate

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"

	"github.com/mia-platform/mlp/internal/utils"
)

const asciiDoubleQuote = "&#34;"

type envVar struct {
	name          string
	value         string
	originalValue string
}

// Interpolate files with values present in ENV variables
func Interpolate(file []byte, prefixes []string, regex string) ([]byte, error) {
	fileString := string(file)
	envs := make(map[string]envVar)
	envs = getVariablesToInterpolate(fileString, envs, regex)

	// return input file if interpolate has nothing to interpolate
	if len(envs) == 0 {
		return file, nil
	}

	err := checkEnvs(envs, prefixes)
	if err != nil {
		return nil, fmt.Errorf("Environment Variable %s not found for file: %s", err.(*EnvNotFoundError).VarName, fileString)
	}

	return interpolateVariables(fileString, envs), nil
}

// Run execute the interpolation command from cli
func Run(prefixes []string, inputPaths []string, outputPath string) {
	fileNames, err := utils.ExtractYAMLFiles(inputPaths)
	utils.CheckError(err, "Error extracting YAML files")

	err = utils.MkdirAll(outputPath)
	utils.CheckError(err, "Error creating output directory")

	for _, fp := range fileNames {
		f, err := utils.ReadFile(fp)
		utils.CheckError(err, "Error reading file")

		interpolatedFile, err := Interpolate(f, prefixes, "\\{\\{([A-Z0-9_]+)\\}\\}")
		utils.CheckError(err, "Error interpolating file")

		fileName, err := filepath.Abs(filepath.Join(outputPath, filepath.Base(fp)))
		err = utils.WriteFile(fileName, interpolatedFile)
		utils.CheckError(err, "Error writing file")
	}
}

// getVariablesToInterpolate extract variables to interpolate from file
func getVariablesToInterpolate(fileContent string, envs map[string]envVar, re string) map[string]envVar {
	for _, parsedVar := range getVarsInString(re, fileContent) {
		env := strings.ReplaceAll(parsedVar[1], " ", "")
		// keep track of the entire pattern found by the regex
		// using as key the variable name
		if _, exists := envs[env]; !exists {
			envs[env] = envVar{name: parsedVar[0]}
		}
	}
	return envs
}

func getVarsInString(regex string, s string) [][]string {
	re := regexp.MustCompile(regex)
	return re.FindAllStringSubmatch(s, -1)
}

func checkEnvs(envs map[string]envVar, prefixes []string) error {
	for env := range envs {
		// get the escaped environment variable
		quotedEnvValue, originalEnvValue, err := getEnv(env, prefixes)
		if err != nil {
			return err
		}

		// discard the initial and final double quotes generated by strconv
		quotedEnvValue = quotedEnvValue[1 : len(quotedEnvValue)-1]
		envs[env] = envVar{
			name:          envs[env].name,
			value:         quotedEnvValue,
			originalValue: originalEnvValue,
		}
	}
	return nil
}

// EnvNotFoundError error raised during interpolation if the ENV is not defined
type EnvNotFoundError struct {
	VarName string
}

func (e *EnvNotFoundError) Error() string {
	return fmt.Sprintf("Environment Variable %s: not found", e.VarName)
}

// getEnv retrieves the value of an ENV variable by prepending a prefix
// to the variable name. It is also possible to pass more than one prefix
// in case the variables have different ones.
func getEnv(env string, prefixes []string) (string, string, error) {
	for _, prefix := range prefixes {
		varPrefixed := prefix + env
		if val, exists := os.LookupEnv(varPrefixed); exists {
			newVal := strings.ReplaceAll(val, `"`, asciiDoubleQuote)
			return strconv.Quote(newVal), val, nil
		}
	}

	if val, exists := os.LookupEnv(env); exists {
		newVal := strings.ReplaceAll(val, `"`, asciiDoubleQuote)
		return strconv.Quote(newVal), val, nil
	}

	return "", "", &EnvNotFoundError{VarName: env}
}

func interpolateVariables(file string, envs map[string]envVar) []byte {
	for env := range envs {
		env := envs[env]

		if strings.TrimSpace(file) == env.name {
			file = strings.ReplaceAll(file, env.name, env.originalValue)
			return []byte(file)
		}

		envValue := strings.ReplaceAll(env.value, `\\`, `\`)

		escapedValueForQuotedString := strings.ReplaceAll(envValue, asciiDoubleQuote, `\"`)
		file = strings.ReplaceAll(file, fmt.Sprintf(`"%s"`, env.name), fmt.Sprintf(`"%s"`, escapedValueForQuotedString))

		file = strings.ReplaceAll(file, env.name, envValue)
	}

	file = strings.ReplaceAll(file, asciiDoubleQuote, `"`)

	return []byte(file)
}
